<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# cmd

```go
import "github.com/Akilan1999/p2p-rendering-computation/cmd"
```

## Index

- [Variables](<#variables>)


## Variables

<a name="AddServer"></a>Variables declared for CLI

```go
var (
    AddServer            string
    ViewImages           string
    CreateVM             string
    ContainerName        string
    BaseImage            string
    Ports                string
    Server               bool
    RemoveVM             string
    ID                   string
    Specs                string
    GPU                  bool
    UpdateServerList     bool
    ServerList           bool
    SetDefaultConfig     bool
    NetworkInterface     bool
    ViewPlugin           bool
    TrackedContainers    bool
    ExecutePlugin        string
    CreateGroup          bool
    Group                string
    Groups               bool
    RemoveContainerGroup bool
    RemoveGroup          string
    MAPPort              string
    DomainName           string
    //FRPProxy             bool
    // Generate only allowed in dev release
    // -- REMOVE ON REGULAR RELEASE --
    Generate   string
    Modulename string
    //--------------------------------
    PullPlugin   string
    RemovePlugin string
    AddMetaData  string
)
```

<a name="AppConfigFlags"></a>

```go
var AppConfigFlags = []cli.Flag{

    &cli.BoolFlag{
        Name:        "Server",
        Aliases:     []string{"s"},
        Usage:       "Starts server",
        EnvVars:     []string{"SERVER"},
        Destination: &Server,
    },
    &cli.BoolFlag{
        Name:        "UpdateServerList",
        Aliases:     []string{"us"},
        Usage:       "Update List of Server available based on servers iptables",
        EnvVars:     []string{"UPDATE_SERVER_LIST"},
        Destination: &UpdateServerList,
    },
    &cli.BoolFlag{
        Name:        "ListServers",
        Aliases:     []string{"ls"},
        Usage:       "List servers which can render tasks",
        EnvVars:     []string{"LIST_SERVERS"},
        Destination: &ServerList,
    },
    &cli.StringFlag{
        Name:        "AddServer",
        Aliases:     []string{"as"},
        Usage:       "Adds server IP address to iptables",
        EnvVars:     []string{"ADD_SERVER"},
        Destination: &AddServer,
    },
    &cli.StringFlag{
        Name:        "ViewImages",
        Aliases:     []string{"vi"},
        Usage:       "View images available on the server IP address",
        EnvVars:     []string{"VIEW_IMAGES"},
        Destination: &ViewImages,
    },
    &cli.StringFlag{
        Name:        "CreateVM",
        Aliases:     []string{"touch"},
        Usage:       "Creates Docker container on the selected server",
        EnvVars:     []string{"CREATE_VM"},
        Destination: &CreateVM,
    },
    &cli.StringFlag{
        Name:        "ContainerName",
        Aliases:     []string{"cn"},
        Usage:       "Specifying the container run on the server side",
        EnvVars:     []string{"CONTAINER_NAME"},
        Destination: &ContainerName,
    },
    &cli.StringFlag{
        Name:        "BaseImage",
        Aliases:     []string{"bi"},
        Usage:       "Specifying the docker base image to template the dockerfile",
        EnvVars:     []string{"CONTAINER_NAME"},
        Destination: &BaseImage,
    },
    &cli.StringFlag{
        Name:        "RemoveVM",
        Aliases:     []string{"rm"},
        Usage:       "Stop and Remove Docker container (IP:port) accompanied by container ID via --ID or --id",
        EnvVars:     []string{"REMOVE_VM"},
        Destination: &RemoveVM,
    },
    &cli.StringFlag{
        Name:        "ID",
        Aliases:     []string{"id"},
        Usage:       "Docker Container ID",
        EnvVars:     []string{"ID"},
        Destination: &ID,
    },
    &cli.StringFlag{
        Name:        "Ports",
        Aliases:     []string{"p"},
        Usage:       "Number of ports to open for the Docker Container",
        EnvVars:     []string{"NUM_PORTS"},
        Destination: &Ports,
    },
    &cli.BoolFlag{
        Name:        "GPU",
        Aliases:     []string{"gpu"},
        Usage:       "Create Docker Containers to access GPU",
        EnvVars:     []string{"USE_GPU"},
        Destination: &GPU,
    },
    &cli.StringFlag{
        Name:        "Specification",
        Aliases:     []string{"specs"},
        Usage:       "Specs of the server node",
        EnvVars:     []string{"SPECS"},
        Destination: &Specs,
    },
    &cli.BoolFlag{
        Name:        "SetDefaultConfig",
        Aliases:     []string{"dc"},
        Usage:       "Sets a default configuration file",
        EnvVars:     []string{"SET_DEFAULT_CONFIG"},
        Destination: &SetDefaultConfig,
    },
    &cli.BoolFlag{
        Name:        "NetworkInterfaces",
        Aliases:     []string{"ni"},
        Usage:       "Shows the network interface in your computer",
        EnvVars:     []string{"NETWORK_INTERFACE"},
        Destination: &NetworkInterface,
    },
    &cli.BoolFlag{
        Name:        "ViewPlugins",
        Aliases:     []string{"vp"},
        Usage:       "Shows plugins available to be executed",
        EnvVars:     []string{"VIEW_PLUGIN"},
        Destination: &ViewPlugin,
    },
    &cli.BoolFlag{
        Name:    "TrackedContainers",
        Aliases: []string{"tc"},
        Usage: "View (currently running) containers which have " +
            "been created from the client side ",
        EnvVars:     []string{"TRACKED_CONTAINERS"},
        Destination: &TrackedContainers,
    },
    &cli.StringFlag{
        Name:        "ExecutePlugin",
        Aliases:     []string{"plugin"},
        Usage:       "Plugin which needs to be executed",
        EnvVars:     []string{"EXECUTE_PLUGIN"},
        Destination: &ExecutePlugin,
    },
    &cli.BoolFlag{
        Name:        "CreateGroup",
        Aliases:     []string{"cgroup"},
        Usage:       "Creates a new group",
        EnvVars:     []string{"CREATE_GROUP"},
        Destination: &CreateGroup,
    },
    &cli.StringFlag{
        Name:        "Group",
        Aliases:     []string{"group"},
        Usage:       "group flag with argument group ID",
        EnvVars:     []string{"GROUP"},
        Destination: &Group,
    },
    &cli.BoolFlag{
        Name:        "Groups",
        Aliases:     []string{"groups"},
        Usage:       "View all groups",
        EnvVars:     []string{"GROUPS"},
        Destination: &Groups,
    },
    &cli.BoolFlag{
        Name:        "RemoveContainerGroup",
        Aliases:     []string{"rmcgroup"},
        Usage:       "Remove specific container in the group",
        EnvVars:     []string{"REMOVE_CONTAINER_GROUP"},
        Destination: &RemoveContainerGroup,
    },
    &cli.StringFlag{
        Name:        "RemoveGroup",
        Aliases:     []string{"rmgroup"},
        Usage:       "Removes the entire group",
        EnvVars:     []string{"REMOVE_GROUP"},
        Destination: &RemoveGroup,
    },
    &cli.StringFlag{
        Name:        "MAPPort",
        Aliases:     []string{"mp"},
        Usage:       "Maps port for a specific port provided as the parameter",
        EnvVars:     []string{"MAPPORT"},
        Destination: &MAPPort,
    },
    &cli.StringFlag{
        Name:        "DomainName",
        Aliases:     []string{"dn"},
        Usage:       "While mapping ports allows to set a domain name to create a mapping in the proxy server",
        EnvVars:     []string{"DOMAINNAME"},
        Destination: &DomainName,
    },

    &cli.StringFlag{
        Name:        "Generate",
        Aliases:     []string{"gen"},
        Usage:       "Generates a new copy of P2PRC which can be modified based on your needs",
        EnvVars:     []string{"GENERATE"},
        Destination: &Generate,
    },
    &cli.StringFlag{
        Name:        "ModuleName",
        Aliases:     []string{"mod"},
        Usage:       "New go project module name",
        EnvVars:     []string{"MODULENAME"},
        Destination: &Modulename,
    },

    &cli.StringFlag{
        Name:        "PullPlugin",
        Aliases:     []string{"pp"},
        Usage:       "Pulls plugin from git repos",
        EnvVars:     []string{"PULLPLUGIN"},
        Destination: &PullPlugin,
    },
    &cli.StringFlag{
        Name:        "RemovePlugin",
        Aliases:     []string{"rp"},
        Usage:       "Removes plugin",
        EnvVars:     []string{"REMOVEPLUGIN"},
        Destination: &RemovePlugin,
    },
    &cli.StringFlag{
        Name:        "AddMetaData",
        Aliases:     []string{"amd"},
        Usage:       "Adds metadata about the current node in the p2p network which is then propagated through the network",
        EnvVars:     []string{"ADDMETADATA"},
        Destination: &AddMetaData,
    },
}
```

<a name="CliAction"></a>

```go
var CliAction = func(ctx *cli.Context) error {
    if Server {
        _, err := server.Server()
        if err != nil {
            fmt.Print(err)
        }

        for {

        }
    }

    if UpdateServerList {
        err := clientIPTable.UpdateIpTableListClient()
        if err != nil {
            fmt.Print(err)
        }

        p2p.PrintIpTable()
    }

    if ServerList {

        p2p.PrintIpTable()
    }

    if AddServer != "" {
        res, err := p2p.ReadIpTable()
        if err != nil {
            fmt.Println(err)
        }

        //Create variable of type IpAddress and set IP address
        // to it
        var IpAddr p2p.IpAddress

        ip4Orip6 := p2p.Ip4or6(AddServer)
        if ip4Orip6 == "version 6" {
            IpAddr.Ipv6 = AddServer
        } else {
            IpAddr.Ipv4 = AddServer
        }

        if Ports != "" {
            IpAddr.ServerPort = Ports
        } else {
            IpAddr.ServerPort = "8088"
        }

        res.IpAddress = append(res.IpAddress, IpAddr)

        res.WriteIpTable()

    }

    if ViewImages != "" {
        imageRes, err := client.ViewContainers(ViewImages)

        if err != nil {
            fmt.Print(err)
        }
        client.PrettyPrint(imageRes)
    }

    if RemoveVM != "" {
        if ID == "" {
            fmt.Println("provide container ID via --ID or --id")
        } else {
            err := client.RemoveContianer(RemoveVM, ID)
            if err != nil {
                fmt.Print(err)
            }
        }
    }

    if CreateVM != "" {

        var PortsInt int

        if Ports != "" {

            fmt.Sscanf(Ports, "%d", &PortsInt)
        }

        imageRes, err := client.StartContainer(CreateVM, PortsInt, GPU, ContainerName, BaseImage)

        if err != nil {
            fmt.Print(err)
        }
        client.PrettyPrint(imageRes)
    }

    if Specs != "" {
        specs, err := client.GetSpecs(Specs)
        if err != nil {
            return err
        }

        client.PrettyPrint(specs)
    }

    if SetDefaultConfig {
        _, err := generate.SetDefaults("P2PRC", false, nil, false)
        if err != nil {
            fmt.Print(err)
        }
    }

    if NetworkInterface {
        err := p2p.ViewNetworkInterface()
        if err != nil {
            fmt.Print(err)
        }
    }

    if ViewPlugin {
        plugins, err := plugin.DetectPlugins()
        if err != nil {
            fmt.Print(err)
        }
        client.PrettyPrint(plugins)
    }

    if TrackedContainers {
        err, trackedContainers := client.ViewTrackedContainers()
        if err != nil {
            fmt.Print(err)
        }
        client.PrettyPrint(trackedContainers)
    }

    if ExecutePlugin != "" {

        if ID != "" {
            err := plugin.CheckRunPlugin(ExecutePlugin, ID)
            if err != nil {
                fmt.Println(err)
            } else {
                fmt.Println("Success")
            }
        } else {
            fmt.Println("provide container ID via --ID or --id")
        }

    }

    if CreateGroup {
        group, err := client.CreateGroup()
        if err != nil {
            return err
        }
        client.PrettyPrint(group)
    }

    if Group != "" {

        if RemoveContainerGroup && ID != "" {
            group, err := client.RemoveContainerGroup(ID, Group)
            if err != nil {
                fmt.Println(err)
            } else {
                client.PrettyPrint(group)
            }
        } else if ID != "" {

            group, err := client.AddContainerToGroup(ID, Group)
            if err != nil {
                fmt.Println(err)
            } else {
                client.PrettyPrint(group)
            }
        } else {
            group, err := client.GetGroup(Group)
            if err != nil {
                fmt.Println(err)
            } else {
                client.PrettyPrint(group)
            }
        }
    }

    if RemoveGroup != "" {
        err := client.RemoveGroup(RemoveGroup)
        if err != nil {
            fmt.Println(err)
        } else {
            fmt.Println("Group Removed")
        }
    }

    if Groups {
        groups, err := client.ReadGroup()
        if err != nil {
            fmt.Println(err)
        } else {
            client.PrettyPrint(groups)
        }
    }

    if PullPlugin != "" {
        err := plugin.DownloadPlugin(PullPlugin)
        if err != nil {
            fmt.Println(err)
        } else {
            fmt.Println("Success")
        }
    }

    if RemovePlugin != "" {
        err := plugin.DeletePlugin(RemovePlugin)
        if err != nil {
            fmt.Println(err)
        } else {
            fmt.Println("Success")
        }
    }

    if AddMetaData != "" {
        err := clientIPTable.AddCustomInformationToIPTable(AddMetaData)
        if err != nil {
            fmt.Println(err)
        } else {
            fmt.Println("Success")
        }
    }

    if MAPPort != "" {
        address, err := client.MAPPort(MAPPort, DomainName)
        if err != nil {
            return err
        }
        if err != nil {
            fmt.Println(err)
        } else {
            client.PrettyPrint(address)
        }
    }

    return nil
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
